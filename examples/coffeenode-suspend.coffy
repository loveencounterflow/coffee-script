
############################################################################################################
# ERROR                     = require 'coffeenode-stacktrace'
njs_util                  = require 'util'
# njs_path                  = require 'path'
njs_fs                    = require 'fs'
#...........................................................................................................
log                       = console.log
rpr                       = njs_util.inspect
suspend                   = require 'coffeenode-suspend'
step                      = suspend.step
after                     = suspend.after
eventually                = suspend.eventually


### TAINT not a test suite just yet, just an example ###


#===========================================================================================================
# EX.: READING A FILE
#-----------------------------------------------------------------------------------------------------------
read_text_file = ( route, handler ) ->
  ### A run-of-the-mill asynchronous file reading function; `handler` should be a NodeJS-compliant callback
  function that expects to be called with `( error, data )` on completion. ###
  ( require 'fs' ).readFile route, 'utf-8', ( error, text ) ->
    if error?
      handler error
    else
      handler null, text

#-----------------------------------------------------------------------------------------------------------
get_text_synchronously = ( text, handler ) ->
  ### A synchronous function with a callback. ###
  handler null, "***#{text}***"

#-----------------------------------------------------------------------------------------------------------
#                         argument to `suspend`:
# result of calling       generator function that
#     `suspend`           accepts `resume` as its
#                          asynchronous callback
#        ↓                           ↓
test_read_text_file_with_suspend = suspend ( resume ) ->*
  ### The consumer of the `read_text_file` function defined above. It is defined by 'decorating' a
  generator function that accepts a `resume` argument with `suspend`. When calling a NodeJS-compliant
  asynchronous function, we simple call that function with `resume`as callback, prepend the call with
  a `yield` statement, and upon completion we'll get a pair `[ error, data, ]` back from `yield`.
  We can than proceed to dealing with an error or further process the data. ###
  try
    text = yield read_text_file __filename, resume
    log "read #{text.length} characters"
  catch error
    log "### THIS ERROR CAUGHT IN GENERATOR ### #{error[ 'message' ]}"

#-----------------------------------------------------------------------------------------------------------
test_read_text_file_with_step = ( route ) ->
  return step ( resume ) =>*
    try
      text = yield read_text_file route, resume
      log "read #{text.length} characters"
    catch error
      log "### THIS ERROR CAUGHT IN GENERATOR ### #{error[ 'message' ]}"

#===========================================================================================================
# EX.: DOING THINGS IN SERIAL AND IN (ORDERED) PARALLEL
#-----------------------------------------------------------------------------------------------------------
double = ( n, handler ) ->
  ### An asynchronous function that takes anywhere between zero and one second of time. ###
  after Math.random(), ->
    Z = n * 2
    log "double: #{n} -> #{Z}"
    handler null, Z
  return null

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_serial = ( n0, n1, handler ) ->
  ### Demonstration of how to use `suspend` / `step` to run multiple asynchronous calls in serial: The
  loop emitting the calls is located in a suspended generator function. Because execution is suspended on
  each turn, we can call the handler when the loop has finished, just as if the asynchronous calls had been
  synchronous calls. Total execution time will be close to the number of calls times the mean time needed
  for each single turn. ###
  Z     = []
  #.........................................................................................................
  step ( resume ) ->*
    try
      for i in [ n0 .. n1 ]
        result = yield double i, resume
        Z.push result
      handler null, Z

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_parallel = ( n0, n1, handler ) ->
  ### Demonstration of how to use `suspend` / `step` to run multiple asynchronous calls in parallel: In this
  case, the loop suspends one call on each turn; we have to keep track of the number of active calls as
  there is no other indication at what point in time all the calls have finished. The results get all
  pushed into a results list, meaning they are bound to appear in random order. Total execution time will
  be close to the maximum execution time of all the calls. ###
  Z                 = []
  active_call_count = 0
  #.........................................................................................................
  for i in [ n0 .. n1 ]
    active_call_count += 1
    step ( resume ) ->*
      result = yield double i, resume
      active_call_count -= 1
      Z.push result
      handler null, Z if active_call_count is 0
  #.........................................................................................................
  return null

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_sorted_parallel = ( n0, n1, handler ) ->
  ### The same as `double_numbers_in_parallel`, except that we keep a tab on where in the result list each
  return value has to go; this necessitates one more closure. ###
  Z                 = []
  active_call_count = 0
  #.........................................................................................................
  for i in [ n0 .. n1 ]
    idx                 = active_call_count
    active_call_count  += 1
    do ( idx ) ->
      step ( resume ) ->*
        result = yield double i, resume
        active_call_count -= 1
        Z[ idx ] = result
        handler null, Z if active_call_count is 0
  #.........................................................................................................
  return null


#===========================================================================================================
# TESTING
#-----------------------------------------------------------------------------------------------------------
test_serial = ->
  double_numbers_in_serial 11, 21, ( error, data ) ->
    throw error if error?
    log "results from serial processing:", data

#-----------------------------------------------------------------------------------------------------------
test_parallel = ->
  double_numbers_in_parallel 11, 21, ( error, data ) ->
    throw error if error?
    log "results from parallel processing:", data

#-----------------------------------------------------------------------------------------------------------
test_sorted_parallel = ->
  double_numbers_in_sorted_parallel 11, 21, ( error, data ) ->
    throw error if error?
    log "results from sorted parallel processing:", data

#-----------------------------------------------------------------------------------------------------------
test_synchronous_call = ->
  step ( resume ) ->*
    log yield get_text_synchronously 'helo',  resume
    log yield get_text_synchronously 'world', resume
    log 'finished.'

############################################################################################################

# do test_serial
# do test_parallel
# step walk_and_talk
# do test_sorted_parallel
# do test_read_text_file_with_suspend
test_read_text_file_with_step __filename
# test_read_text_file_with_step 'NOSUCHFILE'
# do test_synchronous_call



