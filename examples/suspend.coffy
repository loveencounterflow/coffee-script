
############################################################################################################
# ERROR                     = require 'coffeenode-stacktrace'
njs_util                  = require 'util'
# njs_path                  = require 'path'
njs_fs                    = require 'fs'
#...........................................................................................................
log                       = console.log
rpr                       = njs_util.inspect
suspend                   = require 'suspend'

### TAINT not a test suite just yet, just an example ###


#===========================================================================================================
# HELPERS
#-----------------------------------------------------------------------------------------------------------
step = ( stepper ) ->
  ### Like `suspend` (see `https://github.com/jmar777/suspend`), but executing the suspended function
  immediately. ###
  R = suspend stepper
  #.........................................................................................................
  return R()

#-----------------------------------------------------------------------------------------------------------
after = ( time_s, handler ) ->
  ### `after` is a thin shim around `setTimeout` that adheres to NodeJS conventions, taking a `handler`
  callback function as last argument. Also, the timeout is given in humane seconds rather than in ms. ###
  return setTimeout handler, time_s * 1000

#-----------------------------------------------------------------------------------------------------------
eventually = ( handler ) ->
  ### `eventually f` is just another name for `process.nextTick f`—which in turn is basically equivalent to
  `after 0, f`. ###
  return process.nextTick handler

#===========================================================================================================
# EX.: WALK'N'TALK
#-----------------------------------------------------------------------------------------------------------
walk_and_talk = ( resume ) ->
  ### An example to demonstrate that multiple `yield`s are possible within a suspended function. We really
  can serialize asynchronous processing steps this way—think multiple calls to a database while drilling
  down into the data—without invoking the Pyramid of Doom. ###
  log "after"
  yield after 1, resume
  log "a"
  yield after 1, resume
  log "long"
  yield after 1, resume
  log "time"

#===========================================================================================================
# EX.: READING A FILE
#-----------------------------------------------------------------------------------------------------------
read_text_file = ( route, handler ) ->
  ### A run-of-the-mill asynchronous file reading function; `handler` should be a NodeJS-compliant callback
  function that expects to be called with `( error, data )` on completion. ###
  ( require 'fs' ).readFile route, 'utf-8', ( error, text ) ->
    if error?
      handler error
    else
      handler null, text

#-----------------------------------------------------------------------------------------------------------
#                         argument to `suspend`:
# result of calling       generator function that
#     `suspend`           accepts `resume` as its
#                          asynchronous callback
#        ↓                           ↓
test_read_text_file_with_suspend = suspend ( resume ) ->
  ### The consumer of the `read_text_file` function defined above. It is defined by 'decorating' a
  generator function that accepts a `resume` argument with `suspend`. When calling a NodeJS-compliant
  asynchronous function, we simple call that function with `resume`as callback, prepend the call with
  a `yield` statement, and upon completion we'll get a pair `[ error, data, ]` back from `yield`.
  We can than proceed to dealing with an error or further process the data. ###
  [ error
    text  ] = yield read_text_file __filename, resume
  throw error if error?
  log "read #{text.length} characters"

#-----------------------------------------------------------------------------------------------------------
test_read_text_file_with_step = ( route ) ->
  ### Same as `test_read_text_file_with_suspend`, but actually executing the call. ###
  return step ( resume ) =>
    [ error
      text  ] = yield read_text_file route, resume
    throw error if error?
    log "read #{text.length} characters"


#===========================================================================================================
# EX.: DOING THINGS IN SERIAL AND IN (ORDERED) PARALLEL
#-----------------------------------------------------------------------------------------------------------
double = ( n, handler ) ->
  ### An asynchronous function that takes anywhere between zero and one second of time. ###
  after Math.random(), ->
    Z = n * 2
    log "double: #{n} -> #{Z}"
    handler null, Z
  return null

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_serial = ( n0, n1, handler ) ->
  ### Demonstration of how to use `suspend` / `step` to run multiple asynchronous calls in serial: The
  loop emitting the calls is located in a suspended generator function. Because execution is suspended on
  each turn, we can call the handler when the loop has finished, just as if the asynchronous calls had been
  synchronous calls. Total execution time will be close to the number of calls times the mean time needed
  for each single turn. ###
  Z     = []
  #.........................................................................................................
  step ( resume ) ->
    for i in [ n0 .. n1 ]
      [ error
        result ] = yield double i, resume
      handler error if error?
      Z.push result
    handler null, Z

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_parallel = ( n0, n1, handler ) ->
  ### Demonstration of how to use `suspend` / `step` to run multiple asynchronous calls in parallel: In this
  case, the loop suspends one call on each turn; we have to keep track of the number of active calls as
  there is no other indication at what point in time all the calls have finished. The results get all
  pushed into a results list, meaning they are bound to appear in random order. Total execution time will
  be close to the maximum execution time of all the calls. ###
  Z                 = []
  active_call_count = 0
  #.........................................................................................................
  for i in [ n0 .. n1 ]
    active_call_count += 1
    step ( resume ) ->
      [ error
        result ] = yield double i, resume
      active_call_count -= 1
      handler error if error?
      Z.push result
      handler null, Z if active_call_count is 0
  #.........................................................................................................
  return null

#-----------------------------------------------------------------------------------------------------------
double_numbers_in_sorted_parallel = ( n0, n1, handler ) ->
  ### The same as `double_numbers_in_parallel`, except that we keep a tab on where in the result list each
  return value has to go; this necessitates one more closure. ###
  Z                 = []
  active_call_count = 0
  #.........................................................................................................
  for i in [ n0 .. n1 ]
    idx                 = active_call_count
    active_call_count  += 1
    do ( idx ) ->
      step ( resume ) ->
        [ error
          result ] = yield double i, resume
        active_call_count -= 1
        handler error if error?
        Z[ idx ] = result
        handler null, Z if active_call_count is 0
  #.........................................................................................................
  return null


#===========================================================================================================
# TESTING
#-----------------------------------------------------------------------------------------------------------
test_serial = ->
  double_numbers_in_serial 11, 21, ( error, data ) ->
    throw error if error?
    log "results from serial processing:", data

#-----------------------------------------------------------------------------------------------------------
test_parallel = ->
  double_numbers_in_parallel 11, 21, ( error, data ) ->
    throw error if error?
    log "results from parallel processing:", data

#-----------------------------------------------------------------------------------------------------------
test_sorted_parallel = ->
  double_numbers_in_sorted_parallel 11, 21, ( error, data ) ->
    throw error if error?
    log "results from sorted parallel processing:", data


############################################################################################################
# test_serial()
# test_parallel()
# step walk_and_talk
# ( suspend read_file )()
# test_sorted_parallel()
# test_read_text_file_with_suspend()
test_read_text_file_with_step __filename


